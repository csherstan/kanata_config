<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kanata Configuration Visualizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        header p {
            opacity: 0;
            font-size: 1.1em;
        }

        .controls {
            padding: 20px 30px;
            background: #f8f9fa;
            border-bottom: 2px solid #e9ecef;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            background: #667eea;
            color: white;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #6c757d;
        }

        .btn-secondary:hover {
            box-shadow: 0 4px 12px rgba(108, 117, 125, 0.4);
        }

        .btn-success {
            background: #28a745;
        }

        .btn-success:hover {
            box-shadow: 0 4px 12px rgba(40, 167, 69, 0.4);
        }

        .btn-warning {
            background: #ffc107;
            color: #000;
        }

        .btn-warning:hover {
            box-shadow: 0 4px 12px rgba(255, 193, 7, 0.4);
        }

        .btn-danger {
            background: #dc3545;
        }

        .btn-danger:hover {
            box-shadow: 0 4px 12px rgba(220, 53, 69, 0.4);
        }

        .btn-sm {
            padding: 5px 10px;
            font-size: 12px;
        }

        input[type="file"] {
            display: none;
        }

        .layout-selector {
            display: flex;
            gap: 15px;
            margin-left: auto;
            align-items: center;
        }

        .layout-selector label {
            display: flex;
            align-items: center;
            gap: 5px;
            cursor: pointer;
            font-weight: 500;
        }

        .layout-selector input[type="radio"] {
            cursor: pointer;
        }

        .layer-section {
            margin-bottom: 40px;
        }

        .layer-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-radius: 8px 8px 0 0;
        }

        .layer-title {
            font-size: 1.5em;
            font-weight: 700;
        }

        .layer-actions {
            display: flex;
            gap: 10px;
        }

        .add-layer-section {
            padding: 20px 30px;
            background: #f8f9fa;
            border-bottom: 2px solid #e9ecef;
            text-align: center;
        }

        .keyboard-container {
            padding: 20px 30px 40px 30px;
            background: #f8f9fa;
        }

        .keyboard {
            display: grid;
            gap: 4px;
            max-width: 1200px;
            margin: 0 auto;
            background: #343a40;
            padding: 15px;
            border-radius: 0 0 8px 8px;
        }

        .key {
            background: white;
            border: 2px solid #dee2e6;
            border-radius: 4px;
            padding: 8px;
            font-size: 11px;
            font-weight: 600;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 45px;
            position: relative;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .key:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            z-index: 10;
        }

        .key.modified {
            background: #e3f2fd;
            border-color: #2196f3;
        }

        .key.layer-switch {
            background: #e8f5e9;
            border-color: #4caf50;
        }

        .key.tap-hold {
            background: #f3e5f5;
            border-color: #9c27b0;
        }

        .key.transparent {
            background: #f5f5f5;
            border-color: #bdbdbd;
            opacity: 0;
        }

        .key-label {
            font-size: 9px;
            color: #666;
            margin-bottom: 2px;
        }

        .key-action {
            font-size: 11px;
            font-weight: 700;
            color: #000;
            word-break: break-all;
        }

        /* Layout editing mode styles */
        .key.layout-edit-mode {
            cursor: grab;
            border: 2px dashed #667eea;
            background: linear-gradient(135deg, #667eea20 0%, #764ba220 100%);
        }

        .key.layout-edit-mode:active {
            cursor: grabbing;
        }

        .key.layout-edit-mode:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(102, 126, 234, 0.4);
        }

        .key.dragging {
            opacity: 0;
            z-index: 1000;
            cursor: grabbing !important;
            transform: scale(1.05) rotate(3deg);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4);
            filter: brightness(1.2);
        }

        .insert-indicator {
            position: absolute;
            width: 4px;
            background: linear-gradient(to bottom, #fbbf24, #f59e0b);
            border-radius: 2px;
            box-shadow: 0 0 10px rgba(251, 191, 36, 0.8);
            z-index: 2000;
            pointer-events: none;
            animation: pulse-indicator 0.6s ease-in-out infinite alternate;
        }

        @keyframes pulse-indicator {
            from {
                transform: scaleX(0.8);
                opacity: 0;
            }
            to {
                transform: scaleX(1.2);
                opacity: 0;
            }
        }

        .key-controls {
            position: absolute;
            top: 2px;
            right: 2px;
            display: none;
            gap: 2px;
            z-index: 20;
        }

        .key.layout-edit-mode .key-controls {
            display: flex;
        }

        .key-control-btn {
            width: 14px;
            height: 14px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px;
            line-height: 1;
            padding: 0;
            background: #667eea;
            color: white;
            transition: background 0.2s;
        }

        .key-control-btn:hover {
            background: #5568d3;
        }

        .key-control-btn.delete {
            background: #dc3545;
        }

        .key-control-btn.delete:hover {
            background: #c82333;
        }

        .key-order-badge {
            position: absolute;
            bottom: 2px;
            left: 2px;
            background: #48bb78;
            color: white;
            font-size: 10px;
            font-weight: bold;
            padding: 2px 4px;
            border-radius: 3px;
            z-index: 10;
        }

        .key-position-info {
            position: absolute;
            bottom: 2px;
            left: 2px;
            font-size: 8px;
            color: #999;
            display: none;
        }

        .key.layout-edit-mode .key-position-info {
            display: block;
        }

        .add-key-btn {
            position: absolute;
            bottom: 15px;
            right: 15px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: #28a745;
            color: white;
            border: none;
            font-size: 24px;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(40, 167, 69, 0.4);
            transition: all 0.2s;
            z-index: 100;
        }

        .add-key-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 16px rgba(40, 167, 69, 0.5);
        }

        .layout-edit-banner {
            background: #667eea;
            color: white;
            padding: 10px 30px;
            text-align: center;
            font-weight: 600;
            display: none;
        }

        .layout-edit-banner.active {
            display: block;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 12px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        .modal-header {
            font-size: 1.5em;
            font-weight: 700;
            margin-bottom: 20px;
            color: #667eea;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            font-weight: 600;
            margin-bottom: 8px;
            color: #495057;
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 10px;
            border: 2px solid #dee2e6;
            border-radius: 6px;
            font-size: 14px;
        }

        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: #667eea;
        }

        .modal-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 25px;
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #6c757d;
        }

        .empty-state h2 {
            font-size: 1.8em;
            margin-bottom: 15px;
        }

        .empty-state p {
            font-size: 1.1em;
            margin-bottom: 20px;
        }

        .info-box {
            background: #fff3cd;
            border: 2px solid #ffc107;
            border-radius: 6px;
            padding: 15px;
            margin: 20px 30px;
        }

        .info-box h3 {
            color: #856404;
            margin-bottom: 10px;
        }

        .info-box p {
            color: #856404;
            line-height: 1.6;
        }

        .aliases-list {
            max-height: 400px;
            overflow-y: auto;
            margin-bottom: 20px;
        }

        .alias-item {
            background: #f8f9fa;
            border: 2px solid #dee2e6;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .alias-item-content {
            flex: 1;
        }

        .alias-name {
            font-weight: 700;
            color: #667eea;
            margin-bottom: 5px;
        }

        .alias-value {
            font-family: monospace;
            font-size: 13px;
            color: #495057;
        }

        .alias-actions {
            display: flex;
            gap: 5px;
        }

        .empty-aliases {
            text-align: center;
            padding: 40px;
            color: #6c757d;
        }

    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Kanata Configuration Visualizer</h1>
            <p>Load, visualize, and edit your Kanata keyboard configurations</p>
        </header>

        <div class="controls">
            <button class="btn" onclick="document.getElementById('fileInput').click()">Load Config</button>
            <input type="file" id="fileInput" accept=".kbd" onchange="loadFile(event)">
            <button class="btn btn-success" onclick="downloadConfig()">Download Config</button>
            <button class="btn btn-secondary" onclick="createSampleConfig()">Load Sample</button>
            <button class="btn btn-warning" onclick="openAliasesModal()">Manage Aliases</button>
            <button class="btn" id="layoutEditBtn" onclick="toggleLayoutEditMode()">Edit Keyboard Layout</button>
            <select id="layoutSelector" onchange="onLayoutSelectorChange()" style="padding: 8px 12px; border-radius: 6px; border: 1px solid #ddd; font-size: 14px; cursor: pointer;">
                <option value="">-- Select Keyboard Layout --</option>
                <option value="ansi-60">ANSI 60% (61 keys)</option>
                <option value="ansi-tkl">ANSI TKL (87 keys)</option>
                <option value="ansi-full">ANSI Full (104 keys)</option>
                <option value="kinesis-freestyle">Kinesis Freestyle (Gaming)</option>
            </select>
        </div>

        <div class="layout-edit-banner" id="layoutEditBanner">
            Layout Edit Mode: Drag keys to reposition, click edit button to modify properties, or click + to add new keys. Only the base layer is editable.
        </div>

        <div class="keyboard-container">
            <div id="emptyState" class="empty-state">
                <h2>No Configuration Loaded</h2>
                <p>Load an existing Kanata config file or create a sample configuration to get started</p>
                <button class="btn" onclick="createSampleConfig()">Create Sample Config</button>
            </div>
            <div id="layersContainer"></div>
        </div>

        <div class="add-layer-section" id="addLayerSection" style="display: none;">
            <button class="btn btn-success" onclick="openLayerModal()">+ New Layer</button>
        </div>
    </div>

    <div id="keyModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">Edit Key Mapping</div>
            <div class="form-group">
                <label>Key Position</label>
                <input type="text" id="keyLabel" readonly>
            </div>
            <div class="form-group">
                <label>Action Type</label>
                <select id="actionType" onchange="updateActionFields()">
                    <option value="basic">Basic Key</option>
                    <option value="layer-switch">Layer Switch (Persistent)</option>
                    <option value="layer-while-held">Layer While Held</option>
                    <option value="tap-hold">Tap-Hold</option>
                    <option value="transparent">Transparent</option>
                    <option value="alias">Alias Reference</option>
                </select>
            </div>
            <div id="actionFields"></div>
            <div class="modal-actions">
                <button class="btn btn-secondary" onclick="closeKeyModal()">Cancel</button>
                <button class="btn" onclick="saveKeyMapping()">Save</button>
            </div>
        </div>
    </div>

    <div id="layerModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">New Layer</div>
            <div class="form-group">
                <label>Layer Name</label>
                <input type="text" id="newLayerName" placeholder="e.g., numbers, symbols">
            </div>
            <div class="modal-actions">
                <button class="btn btn-secondary" onclick="closeLayerModal()">Cancel</button>
                <button class="btn" onclick="saveNewLayer()">Create</button>
            </div>
        </div>
    </div>

    <div id="aliasesModal" class="modal">
        <div class="modal-content" style="max-width: 700px;">
            <div class="modal-header">Manage Aliases</div>
            <div id="aliasesList" class="aliases-list"></div>
            <div class="modal-actions">
                <button class="btn" onclick="openEditAliasModal(null)">Add New Alias</button>
                <button class="btn btn-secondary" onclick="closeAliasesModal()">Close</button>
            </div>
        </div>
    </div>

    <div id="editAliasModal" class="modal">
        <div class="modal-content">
            <div class="modal-header" id="editAliasHeader">Edit Alias</div>
            <div class="form-group">
                <label>Alias Name (without @)</label>
                <input type="text" id="aliasNameInput" placeholder="e.g., lyr, cap">
            </div>
            <div class="form-group">
                <label>Action Type</label>
                <select id="aliasActionType" onchange="updateAliasActionFields()">
                    <option value="layer-switch">Layer Switch (Persistent)</option>
                    <option value="layer-while-held">Layer While Held</option>
                    <option value="tap-hold">Tap-Hold</option>
                    <option value="custom">Custom Expression</option>
                </select>
            </div>
            <div id="aliasActionFields"></div>
            <div class="modal-actions">
                <button class="btn btn-secondary" onclick="closeEditAliasModal()">Cancel</button>
                <button class="btn" onclick="saveAlias()">Save</button>
            </div>
        </div>
    </div>

    <script>
        // ==================== STATE MANAGEMENT ====================
        const state = {
            config: {
                defsrc: [],      // Array of key codes in order (generated from grid)
                grid: [],        // 2D array organizing keys by rows [[row1_keys], [row2_keys], ...]
                layoutData: {},  // Object mapping key code to {x: 0, y: 0, w: 1, h: 1, gap?: true}
                layers: {},
                aliases: {}
            },
            ui: {
                activeLayer: 'base',
                editingKeyIndex: null,
                editingAlias: null,
                layoutEditMode: false,  // Toggle for layout editing mode
                draggedKey: null,
                draggedIndex: -1,
                currentDropTarget: null
            }
        };

        // Default key dimensions for common keys (in standard key units)
        const DEFAULT_KEY_DIMENSIONS = {
            // Standard modifier widths
            'bspc': { w: 2, h: 1 },
            'tab': { w: 1.5, h: 1 },
            'caps': { w: 1.75, h: 1 },
            'ret': { w: 2.25, h: 1 },
            'lsft': { w: 2.25, h: 1 },
            'rsft': { w: 2.75, h: 1 },
            'lctl': { w: 1.25, h: 1 },
            'lmet': { w: 1.25, h: 1 },
            'lalt': { w: 1.25, h: 1 },
            'spc': { w: 6.25, h: 1 },
            'ralt': { w: 1.25, h: 1 },
            'rmet': { w: 1.25, h: 1 },
            'menu': { w: 1.25, h: 1 },
            'rctl': { w: 1.25, h: 1 },
            'bsls': { w: 1.5, h: 1 },  // ANSI backslash

            // ISO-specific
            'nuhs': { w: 1.25, h: 1 },  // ISO hash/tilde key
            'nubs': { w: 1.25, h: 1 },  // ISO key next to left shift

            // Numpad
            'kprt': { w: 1, h: 2 },  // Numpad enter (height 2)
            'kp+': { w: 1, h: 2 },   // Numpad plus (height 2 on some layouts)
            'kp0': { w: 2, h: 1 },   // Numpad 0 (width 2)
        };

        function getKeyDimensions(keyCode) {
            return DEFAULT_KEY_DIMENSIONS[keyCode] || { w: 1, h: 1 };
        }

        /**
         * Convert grid structure to defsrc array
         * @param {Array<Array<string>>} grid - 2D array of key codes
         * @returns {Array<string>} - Flat array of key codes
         */
        function gridToDefsrc(grid) {
            const defsrc = [];
            for (const row of grid) {
                for (const keyCode of row) {
                    defsrc.push(keyCode);
                }
            }
            return defsrc;
        }

        //  ==================== PRECISE LAYOUT DEFINITIONS ====================
        // These layouts have exact key positions for proper keyboard visualization
        const PRECISE_LAYOUTS = {
            'ansi-60': {
                defsrc: ['grv', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '-', '=', 'bspc', 'tab', 'q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p', '[', ']', '\\', 'caps', 'a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', ';', '\'', 'ret', 'lsft', 'z', 'x', 'c', 'v', 'b', 'n', 'm', ',', '.', '/', 'rsft', 'lctl', 'lmet', 'lalt', 'spc', 'ralt', 'rmet', 'menu', 'rctl'],
                grid: [
                    ['grv', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '-', '=', 'bspc'],
                    ['tab', 'q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p', '[', ']', '\\'],
                    ['caps', 'a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', ';', '\'', 'ret'],
                    ['lsft', 'z', 'x', 'c', 'v', 'b', 'n', 'm', ',', '.', '/', 'rsft'],
                    ['lctl', 'lmet', 'lalt', 'spc', 'ralt', 'rmet', 'menu', 'rctl']
                ],
                layoutData: {
                    'grv': {x: 0, y: 0, w: 1, h: 1},
                    '1': {x: 0, y: 0, w: 1, h: 1},
                    '2': {x: 0, y: 0, w: 1, h: 1},
                    '3': {x: 0, y: 0, w: 1, h: 1},
                    '4': {x: 0, y: 0, w: 1, h: 1},
                    '5': {x: 0, y: 0, w: 1, h: 1},
                    '6': {x: 0, y: 0, w: 1, h: 1},
                    '7': {x: 0, y: 0, w: 1, h: 1},
                    '8': {x: 0, y: 0, w: 1, h: 1},
                    '9': {x: 0, y: 0, w: 1, h: 1},
                    '0': {x: 0, y: 0, w: 1, h: 1},
                    '-': {x: 0, y: 0, w: 1, h: 1},
                    '=': {x: 0, y: 0, w: 1, h: 1},
                    'bspc': {x: 0, y: 0, w: 2, h: 1},
                    'tab': {x: 0, y: 0, w: 1.5, h: 1},
                    'q': {x: 0, y: 0, w: 1, h: 1},
                    'w': {x: 0, y: 0, w: 1, h: 1},
                    'e': {x: 0, y: 0, w: 1, h: 1},
                    'r': {x: 0, y: 0, w: 1, h: 1},
                    't': {x: 0, y: 0, w: 1, h: 1},
                    'y': {x: 0, y: 0, w: 1, h: 1},
                    'u': {x: 0, y: 0, w: 1, h: 1},
                    'i': {x: 0, y: 0, w: 1, h: 1},
                    'o': {x: 0, y: 0, w: 1, h: 1},
                    'p': {x: 0, y: 0, w: 1, h: 1},
                    '[': {x: 0, y: 0, w: 1, h: 1},
                    ']': {x: 0, y: 0, w: 1, h: 1},
                    '\\': {x: 0, y: 0, w: 1.5, h: 1},
                    'caps': {x: 0, y: 0, w: 1.75, h: 1},
                    'a': {x: 0, y: 0, w: 1, h: 1},
                    's': {x: 0, y: 0, w: 1, h: 1},
                    'd': {x: 0, y: 0, w: 1, h: 1},
                    'f': {x: 0, y: 0, w: 1, h: 1},
                    'g': {x: 0, y: 0, w: 1, h: 1},
                    'h': {x: 0, y: 0, w: 1, h: 1},
                    'j': {x: 0, y: 0, w: 1, h: 1},
                    'k': {x: 0, y: 0, w: 1, h: 1},
                    'l': {x: 0, y: 0, w: 1, h: 1},
                    ';': {x: 0, y: 0, w: 1, h: 1},
                    'ret': {x: 0, y: 0, w: 2.25, h: 1},
                    'lsft': {x: 0, y: 0, w: 2.25, h: 1},
                    'z': {x: 0, y: 0, w: 1, h: 1},
                    'x': {x: 0, y: 0, w: 1, h: 1},
                    'c': {x: 0, y: 0, w: 1, h: 1},
                    'v': {x: 0, y: 0, w: 1, h: 1},
                    'b': {x: 0, y: 0, w: 1, h: 1},
                    'n': {x: 0, y: 0, w: 1, h: 1},
                    'm': {x: 0, y: 0, w: 1, h: 1},
                    ',': {x: 0, y: 0, w: 1, h: 1},
                    '.': {x: 0, y: 0, w: 1, h: 1},
                    '/': {x: 0, y: 0, w: 1, h: 1},
                    'rsft': {x: 0, y: 0, w: 2.75, h: 1},
                    'lctl': {x: 0, y: 0, w: 1.25, h: 1},
                    'lmet': {x: 0, y: 0, w: 1.25, h: 1},
                    'lalt': {x: 0, y: 0, w: 1.25, h: 1},
                    'spc': {x: 0, y: 0, w: 6.25, h: 1},
                    'ralt': {x: 0, y: 0, w: 1.25, h: 1},
                    'rmet': {x: 0, y: 0, w: 1.25, h: 1},
                    'menu': {x: 0, y: 0, w: 1.25, h: 1},
                    'rctl': {x: 0, y: 0, w: 1.25, h: 1}
                }
            },
            'ansi-tkl': {
                defsrc: ['esc', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'f10', 'f11', 'f12', 'prnt', 'slck', 'paus', 'grv', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '-', '=', 'bspc', 'ins', 'home', 'pgup', 'tab', 'q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p', '[', ']', '\\', 'del', 'end', 'pgdn', 'caps', 'a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', ';', '\'', 'ret', 'lsft', 'z', 'x', 'c', 'v', 'b', 'n', 'm', ',', '.', '/', 'rsft', 'up', 'lctl', 'lmet', 'lalt', 'spc', 'ralt', 'rmet', 'menu', 'rctl', 'left', 'down', 'rght'],
                grid: [
                    ['esc', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'f10', 'f11', 'f12', 'prnt', 'slck', 'paus'],
                    ['grv', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '-', '=', 'bspc', 'ins', 'home', 'pgup'],
                    ['tab', 'q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p', '[', ']', '\\', 'del', 'end', 'pgdn'],
                    ['caps', 'a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', ';', '\'', 'ret'],
                    ['lsft', 'z', 'x', 'c', 'v', 'b', 'n', 'm', ',', '.', '/', 'rsft', 'up'],
                    ['lctl', 'lmet', 'lalt', 'spc', 'ralt', 'rmet', 'menu', 'rctl', 'left', 'down', 'rght']
                ],
                layoutData: {
                    'esc': {x: 0, y: 0, w: 1, h: 1},
                    'f1': {x: 1, y: 0, w: 1, h: 1},
                    'f2': {x: 0, y: 0, w: 1, h: 1},
                    'f3': {x: 0, y: 0, w: 1, h: 1},
                    'f4': {x: 0, y: 0, w: 1, h: 1},
                    'f5': {x: 0.5, y: 0, w: 1, h: 1},
                    'f6': {x: 0, y: 0, w: 1, h: 1},
                    'f7': {x: 0, y: 0, w: 1, h: 1},
                    'f8': {x: 0, y: 0, w: 1, h: 1},
                    'f9': {x: 0.5, y: 0, w: 1, h: 1},
                    'f10': {x: 0, y: 0, w: 1, h: 1},
                    'f11': {x: 0, y: 0, w: 1, h: 1},
                    'f12': {x: 0, y: 0, w: 1, h: 1},
                    'prnt': {x: 0.25, y: 0, w: 1, h: 1},
                    'slck': {x: 0, y: 0, w: 1, h: 1},
                    'paus': {x: 0, y: 0, w: 1, h: 1},
                    'grv': {x: 0, y: 0, w: 1, h: 1},
                    '1': {x: 0, y: 0, w: 1, h: 1},
                    '2': {x: 0, y: 0, w: 1, h: 1},
                    '3': {x: 0, y: 0, w: 1, h: 1},
                    '4': {x: 0, y: 0, w: 1, h: 1},
                    '5': {x: 0, y: 0, w: 1, h: 1},
                    '6': {x: 0, y: 0, w: 1, h: 1},
                    '7': {x: 0, y: 0, w: 1, h: 1},
                    '8': {x: 0, y: 0, w: 1, h: 1},
                    '9': {x: 0, y: 0, w: 1, h: 1},
                    '0': {x: 0, y: 0, w: 1, h: 1},
                    '-': {x: 0, y: 0, w: 1, h: 1},
                    '=': {x: 0, y: 0, w: 1, h: 1},
                    'bspc': {x: 0, y: 0, w: 2, h: 1},
                    'ins': {x: 0.25, y: 0, w: 1, h: 1},
                    'home': {x: 0, y: 0, w: 1, h: 1},
                    'pgup': {x: 0, y: 0, w: 1, h: 1},
                    'tab': {x: 0, y: 0, w: 1.5, h: 1},
                    'q': {x: 0, y: 0, w: 1, h: 1},
                    'w': {x: 0, y: 0, w: 1, h: 1},
                    'e': {x: 0, y: 0, w: 1, h: 1},
                    'r': {x: 0, y: 0, w: 1, h: 1},
                    't': {x: 0, y: 0, w: 1, h: 1},
                    'y': {x: 0, y: 0, w: 1, h: 1},
                    'u': {x: 0, y: 0, w: 1, h: 1},
                    'i': {x: 0, y: 0, w: 1, h: 1},
                    'o': {x: 0, y: 0, w: 1, h: 1},
                    'p': {x: 0, y: 0, w: 1, h: 1},
                    '[': {x: 0, y: 0, w: 1, h: 1},
                    ']': {x: 0, y: 0, w: 1, h: 1},
                    '\\': {x: 0, y: 0, w: 1.5, h: 1},
                    'del': {x: 0.25, y: 0, w: 1, h: 1},
                    'end': {x: 0, y: 0, w: 1, h: 1},
                    'pgdn': {x: 0, y: 0, w: 1, h: 1},
                    'caps': {x: 0, y: 0, w: 1.75, h: 1},
                    'a': {x: 0, y: 0, w: 1, h: 1},
                    's': {x: 0, y: 0, w: 1, h: 1},
                    'd': {x: 0, y: 0, w: 1, h: 1},
                    'f': {x: 0, y: 0, w: 1, h: 1},
                    'g': {x: 0, y: 0, w: 1, h: 1},
                    'h': {x: 0, y: 0, w: 1, h: 1},
                    'j': {x: 0, y: 0, w: 1, h: 1},
                    'k': {x: 0, y: 0, w: 1, h: 1},
                    'l': {x: 0, y: 0, w: 1, h: 1},
                    ';': {x: 0, y: 0, w: 1, h: 1},
                    'ret': {x: 0, y: 0, w: 2.25, h: 1},
                    'lsft': {x: 0, y: 0, w: 2.25, h: 1},
                    'z': {x: 0, y: 0, w: 1, h: 1},
                    'x': {x: 0, y: 0, w: 1, h: 1},
                    'c': {x: 0, y: 0, w: 1, h: 1},
                    'v': {x: 0, y: 0, w: 1, h: 1},
                    'b': {x: 0, y: 0, w: 1, h: 1},
                    'n': {x: 0, y: 0, w: 1, h: 1},
                    'm': {x: 0, y: 0, w: 1, h: 1},
                    ',': {x: 0, y: 0, w: 1, h: 1},
                    '.': {x: 0, y: 0, w: 1, h: 1},
                    '/': {x: 0, y: 0, w: 1, h: 1},
                    'rsft': {x: 0, y: 0, w: 2.75, h: 1},
                    'up': {x: 1.25, y: 0, w: 1, h: 1},
                    'lctl': {x: 0, y: 0, w: 1.25, h: 1},
                    'lmet': {x: 0, y: 0, w: 1.25, h: 1},
                    'lalt': {x: 0, y: 0, w: 1.25, h: 1},
                    'spc': {x: 0, y: 0, w: 6.25, h: 1},
                    'ralt': {x: 0, y: 0, w: 1.25, h: 1},
                    'rmet': {x: 0, y: 0, w: 1.25, h: 1},
                    'menu': {x: 0, y: 0, w: 1.25, h: 1},
                    'rctl': {x: 0, y: 0, w: 1.25, h: 1},
                    'left': {x: 0.25, y: 0, w: 1, h: 1},
                    'down': {x: 0, y: 0, w: 1, h: 1},
                    'rght': {x: 0, y: 0, w: 1, h: 1}
                }
            },
            'ansi-full': {
                defsrc: ['esc', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'f10', 'f11', 'f12', 'prnt', 'slck', 'paus', 'grv', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '-', '=', 'bspc', 'ins', 'home', 'pgup', 'nlck', 'kp/', 'kp*', 'kp-', 'tab', 'q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p', '[', ']', '\\', 'del', 'end', 'pgdn', 'kp7', 'kp8', 'kp9', 'kp+', 'caps', 'a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', ';', '\'', 'ret', 'kp4', 'kp5', 'kp6', 'lsft', 'z', 'x', 'c', 'v', 'b', 'n', 'm', ',', '.', '/', 'rsft', 'up', 'kp1', 'kp2', 'kp3', 'kprt', 'lctl', 'lmet', 'lalt', 'spc', 'ralt', 'rmet', 'menu', 'rctl', 'left', 'down', 'rght', 'kp0', 'kp.'],
                grid: [
                    ['esc', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'f10', 'f11', 'f12', 'prnt', 'slck', 'paus'],
                    ['grv', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '-', '=', 'bspc', 'ins', 'home', 'pgup', 'nlck', 'kp/', 'kp*', 'kp-'],
                    ['tab', 'q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p', '[', ']', '\\', 'del', 'end', 'pgdn', 'kp7', 'kp8', 'kp9', 'kp+'],
                    ['caps', 'a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', ';', '\'', 'ret', 'kp4', 'kp5', 'kp6'],
                    ['lsft', 'z', 'x', 'c', 'v', 'b', 'n', 'm', ',', '.', '/', 'rsft', 'up', 'kp1', 'kp2', 'kp3', 'kprt'],
                    ['lctl', 'lmet', 'lalt', 'spc', 'ralt', 'rmet', 'menu', 'rctl', 'left', 'down', 'rght', 'kp0', 'kp.']
                ],
                layoutData: {
                    'esc': {x: 0, y: 0, w: 1, h: 1},
                    'f1': {x: 1.0, y: 0, w: 1, h: 1},
                    'f2': {x: 0, y: 0, w: 1, h: 1},
                    'f3': {x: 0, y: 0, w: 1, h: 1},
                    'f4': {x: 0, y: 0, w: 1, h: 1},
                    'f5': {x: 0.5, y: 0, w: 1, h: 1},
                    'f6': {x: 0, y: 0, w: 1, h: 1},
                    'f7': {x: 0, y: 0, w: 1, h: 1},
                    'f8': {x: 0, y: 0, w: 1, h: 1},
                    'f9': {x: 0.5, y: 0, w: 1, h: 1},
                    'f10': {x: 0, y: 0, w: 1, h: 1},
                    'f11': {x: 0, y: 0, w: 1, h: 1},
                    'f12': {x: 0, y: 0, w: 1, h: 1},
                    'prnt': {x: 0.25, y: 0, w: 1, h: 1},
                    'slck': {x: 0, y: 0, w: 1, h: 1},
                    'paus': {x: 0, y: 0, w: 1, h: 1},
                    'grv': {x: 0, y: 0, w: 1, h: 1},
                    '1': {x: 0, y: 0, w: 1, h: 1},
                    '2': {x: 0, y: 0, w: 1, h: 1},
                    '3': {x: 0, y: 0, w: 1, h: 1},
                    '4': {x: 0, y: 0, w: 1, h: 1},
                    '5': {x: 0, y: 0, w: 1, h: 1},
                    '6': {x: 0, y: 0, w: 1, h: 1},
                    '7': {x: 0, y: 0, w: 1, h: 1},
                    '8': {x: 0, y: 0, w: 1, h: 1},
                    '9': {x: 0, y: 0, w: 1, h: 1},
                    '0': {x: 0, y: 0, w: 1, h: 1},
                    '-': {x: 0, y: 0, w: 1, h: 1},
                    '=': {x: 0, y: 0, w: 1, h: 1},
                    'bspc': {x: 0, y: 0, w: 2, h: 1},
                    'ins': {x: 0.25, y: 0, w: 1, h: 1},
                    'home': {x: 0, y: 0, w: 1, h: 1},
                    'pgup': {x: 0, y: 0, w: 1, h: 1},
                    'nlck': {x: 0.25, y: 0, w: 1, h: 1},
                    'kp/': {x: 0, y: 0, w: 1, h: 1},
                    'kp*': {x: 0, y: 0, w: 1, h: 1},
                    'kp-': {x: 0, y: 0, w: 1, h: 1},
                    'tab': {x: 0, y: 0, w: 1.5, h: 1},
                    'q': {x: 0, y: 0, w: 1, h: 1},
                    'w': {x: 0, y: 0, w: 1, h: 1},
                    'e': {x: 0, y: 0, w: 1, h: 1},
                    'r': {x: 0, y: 0, w: 1, h: 1},
                    't': {x: 0, y: 0, w: 1, h: 1},
                    'y': {x: 0, y: 0, w: 1, h: 1},
                    'u': {x: 0, y: 0, w: 1, h: 1},
                    'i': {x: 0, y: 0, w: 1, h: 1},
                    'o': {x: 0, y: 0, w: 1, h: 1},
                    'p': {x: 0, y: 0, w: 1, h: 1},
                    '[': {x: 0, y: 0, w: 1, h: 1},
                    ']': {x: 0, y: 0, w: 1, h: 1},
                    '\\': {x: 0, y: 0, w: 1.5, h: 1},
                    'del': {x: 0.25, y: 0, w: 1, h: 1},
                    'end': {x: 0, y: 0, w: 1, h: 1},
                    'pgdn': {x: 0, y: 0, w: 1, h: 1},
                    'kp7': {x: 0.25, y: 0, w: 1, h: 1},
                    'kp8': {x: 0, y: 0, w: 1, h: 1},
                    'kp9': {x: 0, y: 0, w: 1, h: 1},
                    'kp+': {x: 0, y: 0, w: 1, h: 2},
                    'caps': {x: 0, y: 0, w: 1.75, h: 1},
                    'a': {x: 0, y: 0, w: 1, h: 1},
                    's': {x: 0, y: 0, w: 1, h: 1},
                    'd': {x: 0, y: 0, w: 1, h: 1},
                    'f': {x: 0, y: 0, w: 1, h: 1},
                    'g': {x: 0, y: 0, w: 1, h: 1},
                    'h': {x: 0, y: 0, w: 1, h: 1},
                    'j': {x: 0, y: 0, w: 1, h: 1},
                    'k': {x: 0, y: 0, w: 1, h: 1},
                    'l': {x: 0, y: 0, w: 1, h: 1},
                    ';': {x: 0, y: 0, w: 1, h: 1},
                    'ret': {x: 0, y: 0, w: 2.25, h: 1},
                    'kp4': {x: 4.5, y: 0, w: 1, h: 1},
                    'kp5': {x: 0, y: 0, w: 1, h: 1},
                    'kp6': {x: 0, y: 0, w: 1, h: 1},
                    'lsft': {x: 0, y: 0, w: 2.25, h: 1},
                    'z': {x: 0, y: 0, w: 1, h: 1},
                    'x': {x: 0, y: 0, w: 1, h: 1},
                    'c': {x: 0, y: 0, w: 1, h: 1},
                    'v': {x: 0, y: 0, w: 1, h: 1},
                    'b': {x: 0, y: 0, w: 1, h: 1},
                    'n': {x: 0, y: 0, w: 1, h: 1},
                    'm': {x: 0, y: 0, w: 1, h: 1},
                    ',': {x: 0, y: 0, w: 1, h: 1},
                    '.': {x: 0, y: 0, w: 1, h: 1},
                    '/': {x: 0, y: 0, w: 1, h: 1},
                    'rsft': {x: 0, y: 0, w: 2.75, h: 1},
                    'up': {x: 1.25, y: 0, w: 1, h: 1},
                    'kp1': {x: 1.25, y: 0, w: 1, h: 1},
                    'kp2': {x: 0, y: 0, w: 1, h: 1},
                    'kp3': {x: 0, y: 0, w: 1, h: 1},
                    'kprt': {x: 0, y: 0, w: 1, h: 2},
                    'lctl': {x: 0, y: 0, w: 1.25, h: 1},
                    'lmet': {x: 0, y: 0, w: 1.25, h: 1},
                    'lalt': {x: 0, y: 0, w: 1.25, h: 1},
                    'spc': {x: 0, y: 0, w: 6.25, h: 1},
                    'ralt': {x: 0, y: 0, w: 1.25, h: 1},
                    'rmet': {x: 0, y: 0, w: 1.25, h: 1},
                    'menu': {x: 0, y: 0, w: 1.25, h: 1},
                    'rctl': {x: 0, y: 0, w: 1.25, h: 1},
                    'left': {x: 0.25, y: 0, w: 1, h: 1},
                    'down': {x: 0, y: 0, w: 1, h: 1},
                    'rght': {x: 0, y: 0, w: 1, h: 1},
                    'kp0': {x: 0.25, y: 0, w: 2, h: 1},
                    'kp.': {x: 0, y: 0, w: 1, h: 1}
                }
            },
            'kinesis-freestyle': {
                defsrc: ['esc', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'f10', 'f11', 'f12', '=', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '-', 'tab', 'q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p', '\\', 'caps', 'a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', ';', '\'', 'lsft', 'z', 'x', 'c', 'v', 'b', 'n', 'm', ',', '.', '/', 'rsft', 'grv', 'ins', 'left', 'rght', 'up', 'down', '[', ']', 'lctl', 'lalt', 'ralt', 'rctl', 'home', 'end', 'pgup', 'pgdn', 'bspc', 'del', 'lmet', 'rmet', 'spc', 'ret'],
                grid: [
                    ['esc', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'f10', 'f11', 'f12' ,'prnt', 'slck', 'paus', 'del'],
                    ['grv', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '-', '=', 'bspc', 'home'],
                    ['tab', 'q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p', '[', ']','\\', 'end'],
                    ['caps', 'a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', ';', '\'', 'ret', 'pgup'],
                    ['lsft', 'z', 'x', 'c', 'v', 'b', 'n', 'm', ',', '.', '/', 'rsft', 'up', 'pgdn'],
                    ['lctl', 'lmet', 'lalt', 'spc', 'ralt', 'rctl', 'left', 'down', 'rght'],
                ],
                layoutData: {
                    'esc': {x: 0, y: 0, w: 1, h: 1},
                    'f1': {x: 1.0, y: 0, w: 1, h: 1},
                    'f2': {x: 0, y: 0, w: 1, h: 1},
                    'f3': {x: 0, y: 0, w: 1, h: 1},
                    'f4': {x: 0, y: 0, w: 1, h: 1},
                    'f5': {x: 0, y: 0, w: 1, h: 1},
                    'f6': {x: 0, y: 0, w: 1, h: 1},
                    'f7': {x: 0, y: 0, w: 1, h: 1},
                    'f8': {x: 2, y: 0, w: 1, h: 1},
                    'f9': {x: 0, y: 0, w: 1, h: 1},
                    'f10': {x: 0, y: 0, w: 1, h: 1},
                    'f11': {x: 0, y: 0, w: 1, h: 1},
                    'f12': {x: 0, y: 0, w: 1, h: 1},
                    'prnt': {x: 0, y: 0, w: 1, h: 1},
                    'slck': {x: 0, y: 0, w: 1, h: 1},
                    'paus': {x: 0, y: 0, w: 1, h: 1},
                    'del': {x: 0, y: 0, w: 1, h: 1},
                    'grv': {x: 2, y: 0, w: 1, h: 1},
                    '1': {x: 0, y: 0, w: 1, h: 1},
                    '2': {x: 0, y: 0, w: 1, h: 1},
                    '3': {x: 0, y: 0, w: 1, h: 1},
                    '4': {x: 0, y: 0, w: 1, h: 1},
                    '5': {x: 0, y: 0, w: 1, h: 1},
                    '6': {x: 0, y: 0, w: 1, h: 1},
                    '7': {x: 2, y: 0, w: 1, h: 1},
                    '8': {x: 0, y: 0, w: 1, h: 1},
                    '9': {x: 0, y: 0, w: 1, h: 1},
                    '0': {x: 0, y: 0, w: 1, h: 1},
                    '-': {x: 0, y: 0, w: 1, h: 1},
                    '=': {x: 0, y: 0, w: 1, h: 1},
                    'bspc': {x: 0, y: 0, w: 2, h: 1},
                    'home': {x: 0, y: 0, w: 1, h: 1},
                    'tab': {x: 2, y: 0, w: 1.5, h: 1},
                    'q': {x: 0, y: 0, w: 1, h: 1},
                    'w': {x: 0, y: 0, w: 1, h: 1},
                    'e': {x: 0, y: 0, w: 1, h: 1},
                    'r': {x: 0, y: 0, w: 1, h: 1},
                    't': {x: 0, y: 0, w: 1, h: 1},
                    'y': {x: 2.0, y: 0, w: 1, h: 1},
                    'u': {x: 0, y: 0, w: 1, h: 1},
                    'i': {x: 0, y: 0, w: 1, h: 1},
                    'o': {x: 0, y: 0, w: 1, h: 1},
                    'p': {x: 0, y: 0, w: 1, h: 1},
                    '[': {x: 0, y: 0, w: 1, h: 1},
                    ']': {x: 0, y: 0, w: 1, h: 1},
                    '\\': {x: 0, y: 0, w: 1.5, h: 1},
                    'end': {x: 0, y: 0, w: 1, h: 1},
                    'caps': {x: 2, y: 0, w: 2, h: 1},
                    'a': {x: 0, y: 0, w: 1, h: 1},
                    's': {x: 0, y: 0, w: 1, h: 1},
                    'd': {x: 0, y: 0, w: 1, h: 1},
                    'f': {x: 0, y: 0, w: 1, h: 1},
                    'g': {x: 0, y: 0, w: 1, h: 1},
                    'h': {x: 1.75, y: 0, w: 1, h: 1},
                    'j': {x: 0, y: 0, w: 1, h: 1},
                    'k': {x: 0, y: 0, w: 1, h: 1},
                    'l': {x: 0, y: 0, w: 1, h: 1},
                    ';': {x: 0, y: 0, w: 1, h: 1},
                    '\'': {x: 0, y: 0, w: 1, h: 1},
                    'ret': {x: 0, y: 0, w: 2.25, h: 1},
                    'pgup': {x: 0, y: 0, w: 1, h: 1},
                    'lsft': {x: 2, y: 0, w: 2.5, h: 1},
                    'z': {x: 0, y: 0, w: 1, h: 1},
                    'x': {x: 0, y: 0, w: 1, h: 1},
                    'c': {x: 0, y: 0, w: 1, h: 1},
                    'v': {x: 0, y: 0, w: 1, h: 1},
                    'b': {x: 0, y: 0, w: 1, h: 1},
                    'n': {x: 1.75, y: 0, w: 1, h: 1},
                    'm': {x: 0, y: 0, w: 1, h: 1},
                    ',': {x: 0, y: 0, w: 1, h: 1},
                    '.': {x: 0, y: 0, w: 1, h: 1},
                    '/': {x: 0, y: 0, w: 1, h: 1},
                    'rsft': {x: 0, y: 0, w: 1.75, h: 1},
                    'up': {x: 0, y: 0, w: 1, h: 1},
                    'pgdn': {x: 0, y: 0, w: 1, h: 1},
                    'lctl': {x: 2, y: 0, w: 1.5, h: 1},
                    'lmet': {x: 0, y: 0, w: 1, h: 1},
                    'lalt': {x: 0, y: 0, w: 1.5, h: 1},
                    'spc': {x: 0, y: 0, w: 7.75, h: 1},
                    'ralt': {x: 0, y: 0, w: 1.5, h: 1},
                    'rctl': {x: 0, y: 0, w: 1.75, h: 1},
                    'left': {x: 0, y: 0, w: 1, h: 1},
                    'down': {x: 0, y: 0, w: 1, h: 1},
                    'rght': {x: 0, y: 0, w: 1, h: 1},
                }
            }
        };

        // ==================== CONFIG PARSER ====================
        function tokenize(text) {
            // Remove comments
            text = text.replace(/;;[^\n]*/g, '');
            text = text.replace(/#\|[\s\S]*?\|#/g, '');

            const tokens = [];
            let current = '';
            let inString = false;

            for (let i = 0; i < text.length; i++) {
                const char = text[i];

                if (char === '"') {
                    inString = !inString;
                    current += char;
                } else if (inString) {
                    current += char;
                } else if (char === '(' || char === ')') {
                    if (current.trim()) {
                        tokens.push(current.trim());
                        current = '';
                    }
                    tokens.push(char);
                } else if (/\s/.test(char)) {
                    if (current.trim()) {
                        tokens.push(current.trim());
                        current = '';
                    }
                } else {
                    current += char;
                }
            }

            if (current.trim()) {
                tokens.push(current.trim());
            }

            return tokens;
        }

        function parseExpression(tokens, index) {
            if (tokens[index] !== '(') {
                return { value: tokens[index], next: index + 1 };
            }

            const expr = [];
            index++; // skip opening paren

            while (index < tokens.length && tokens[index] !== ')') {
                const result = parseExpression(tokens, index);
                expr.push(result.value);
                index = result.next;
            }

            return { value: expr, next: index + 1 }; // skip closing paren
        }

        function parseConfig(text) {
            const tokens = tokenize(text);
            const config = {
                defsrc: [],                layoutData: {
                },
                layers: {},
                aliases: {}
            };

            // Extract layout data from structured comments
            const layoutData = extractLayoutData(text);

            let i = 0;
            while (i < tokens.length) {
                const result = parseExpression(tokens, i);
                const expr = result.value;
                i = result.next;

                if (Array.isArray(expr) && expr.length > 0) {
                    const command = expr[0];

                    if (command === 'defsrc') {
                        // Parse defsrc as flat array
                        config.defsrc = expr.slice(1);

                        // Apply layout data if available, otherwise auto-generate
                        if (layoutData && Object.keys(layoutData).length === config.defsrc.length) {
                            config.layoutData = layoutData;
                        } else {
                            // Auto-generate layout data with basic row-based positioning
                            config.layoutData = autoGenerateLayoutData(config.defsrc);
                        }
                    } else if (command === 'deflayer') {
                        const layerName = expr[1];
                        config.layers[layerName] = expr.slice(2);
                    } else if (command === 'defalias') {
                        for (let j = 1; j < expr.length; j += 2) {
                            const aliasName = expr[j];
                            const aliasValue = expr[j + 1];
                            config.aliases[aliasName] = Array.isArray(aliasValue)
                                ? '(' + aliasValue.join(' ') + ')'
                                : aliasValue;
                        }
                    }
                }
            }

            return config;
        }

        // Extract layout data from structured comment block
        // Format: ;; LAYOUT_DATA_V1
        //         ;; {"key":"esc","x":0,"y":0,"w":1,"h":1}
        //         ;; END_LAYOUT_DATA
        function extractLayoutData(text) {
            const layoutData = {};
            const lines = text.split('\n');
            let inLayoutBlock = false;

            for (const line of lines) {
                if (line.trim() === ';; LAYOUT_DATA_V1') {
                    inLayoutBlock = true;
                    continue;
                }
                if (line.trim() === ';; END_LAYOUT_DATA') {
                    inLayoutBlock = false;
                    break;
                }
                if (inLayoutBlock && line.trim().startsWith(';;')) {
                    try {
                        const jsonStr = line.trim().substring(2).trim();
                        const keyData = JSON.parse(jsonStr);
                        if (keyData.key) {
                            layoutData[keyData.key] = {
                                x: keyData.x,
                                y: keyData.y,
                                w: keyData.w,
                                h: keyData.h
                            };
                        }
                    } catch (e) {
                        console.error('Failed to parse layout data line:', line, e);
                    }
                }
            }

            return layoutData;
        }

        // Auto-generate layout data for keys using row-based positioning
        // This provides a basic fallback when no explicit layout is defined
        function autoGenerateLayoutData(defsrc) {
            const layoutData = {};
            const rows = groupKeysIntoRows(defsrc);

            let y = 0;
            for (const row of rows) {
                let x = 0;
                for (const key of row) {
                    const dims = getKeyDimensions(key);
                    layoutData[key] = {
                        x: x,
                        y: y,
                        w: dims.w,
                        h: dims.h
                    };
                    x += dims.w;
                }
                y += 1;
            }

            return layoutData;
        }

        // Helper to group flat keys into rows based on common patterns
        function groupKeysIntoRows(flatKeys) {
            // Common row lengths for standard keyboards
            const rows = [];
            let currentRow = [];

            // Simple heuristic: detect row boundaries by key patterns
            for (let i = 0; i < flatKeys.length; i++) {
                const key = flatKeys[i];
                currentRow.push(key);

                // End of row detection based on common patterns
                const nextKey = flatKeys[i + 1];
                if (!nextKey ||
                    (key === 'bspc' && nextKey === 'tab') ||
                    (key === 'bsls' && nextKey === 'caps') ||
                    (key === 'ret' && (nextKey === 'lsft' || nextKey === 'lctl')) ||
                    (key === 'rsft' && nextKey === 'lctl') ||
                    (key === 'rctl' && !nextKey)) {
                    rows.push([...currentRow]);
                    currentRow = [];
                }
            }

            // Add any remaining keys
            if (currentRow.length > 0) {
                rows.push(currentRow);
            }

            return rows.length > 0 ? rows : [flatKeys];
        }

        // ==================== CONFIG GENERATOR ====================
        function generateConfig(config) {
            let output = ';; Generated by Kanata Configuration Visualizer\n\n';

            // Generate layout data block
            if (config.layoutData && Object.keys(config.layoutData).length > 0) {
                output += ';; LAYOUT_DATA_V1\n';
                // Sort keys by position (top to bottom, left to right) for readability
                const sortedKeys = Object.entries(config.layoutData)
                    .sort((a, b) => {
                        const [keyA, dataA] = a;
                        const [keyB, dataB] = b;
                        if (dataA.y !== dataB.y) return dataA.y - dataB.y;
                        return dataA.x - dataB.x;
                    });

                for (const [key, data] of sortedKeys) {
                    const obj = {key, x: data.x, y: data.y, w: data.w, h: data.h};
                    output += `;; ${JSON.stringify(obj)}\n`;
                }
                output += ';; END_LAYOUT_DATA\n\n';
            }

            // Generate defsrc using grid structure for human-readable rows
            if (config.defsrc && config.defsrc.length > 0) {
                output += '(defsrc\n';

                if (config.grid && config.grid.length > 0) {
                    // Use grid structure for row-based layout
                    config.grid.forEach(row => {
                        output += '  ';
                        row.forEach(keyCode => {
                            output += keyCode + ' ';
                        });
                        output += '\n';
                    });
                } else {
                    // Fallback: group by y-position (legacy behavior)
                    const keysByRow = {};
                    config.defsrc.forEach(key => {
                        const data = config.layoutData[key];
                        if (data) {
                            const y = data.y;
                            if (!keysByRow[y]) keysByRow[y] = [];
                            keysByRow[y].push(key);
                        }
                    });

                    const sortedRows = Object.keys(keysByRow).map(Number).sort((a, b) => a - b);
                    for (const y of sortedRows) {
                        output += '  ' + keysByRow[y].join(' ') + '\n';
                    }
                }

                output += ')\n\n';
            }

            // Generate aliases
            if (Object.keys(config.aliases).length > 0) {
                output += '(defalias\n';
                for (const [name, value] of Object.entries(config.aliases)) {
                    output += `  ${name} ${value}\n`;
                }
                output += ')\n\n';
            }

            // Generate layers with same structure as defsrc
            for (const [layerName, actions] of Object.entries(config.layers)) {
                output += `(deflayer ${layerName}\n`;

                if (config.grid && config.grid.length > 0) {
                    // Use grid structure for row-based layout
                    config.grid.forEach(row => {
                        output += '  ';
                        row.forEach(keyCode => {

                            // Find action by matching defsrc index
                            const defsrcIndex = config.defsrc.indexOf(keyCode);
                            const action = actions[defsrcIndex] || '_';
                            output += action + ' ';
                        });
                        output += '\n';
                    });
                } else {
                    // Fallback: group by y-position (legacy behavior)
                    const keysByRow = {};
                    config.defsrc.forEach((key, idx) => {
                        const data = config.layoutData[key];
                        if (data) {
                            const y = data.y;
                            if (!keysByRow[y]) keysByRow[y] = [];
                            keysByRow[y].push(actions[idx] || key);
                        }
                    });

                    const sortedRows = Object.keys(keysByRow).map(Number).sort((a, b) => a - b);
                    for (const y of sortedRows) {
                        output += '  ' + keysByRow[y].join(' ') + '\n';
                    }
                }

                output += ')\n\n';
            }

            return output;
        }

        // ==================== KEYBOARD RENDERER ====================
        function renderKeyboard() {
            const container = document.getElementById('layersContainer');

            if (Object.keys(state.config.layers).length === 0 || state.config.defsrc.length === 0) {
                container.innerHTML = '';
                document.getElementById('emptyState').style.display = 'block';
                document.getElementById('addLayerSection').style.display = 'none';
                return;
            }

            document.getElementById('emptyState').style.display = 'none';
            document.getElementById('addLayerSection').style.display = 'block';
            container.innerHTML = '';

            // Render each layer
            for (const [layerName, layerActions] of Object.entries(state.config.layers)) {
                const layerSection = document.createElement('div');
                layerSection.className = 'layer-section';

                // Create header
                const header = document.createElement('div');
                header.className = 'layer-header';

                const title = document.createElement('div');
                title.className = 'layer-title';
                title.textContent = layerName;

                const actions = document.createElement('div');
                actions.className = 'layer-actions';

                if (Object.keys(state.config.layers).length > 1) {
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'btn btn-sm btn-danger';
                    deleteBtn.textContent = 'Delete Layer';
                    deleteBtn.onclick = () => deleteLayer(layerName);
                    actions.appendChild(deleteBtn);
                }

                header.appendChild(title);
                header.appendChild(actions);
                layerSection.appendChild(header);

                // Create keyboard for this layer - absolute positioning
                const keyboard = document.createElement('div');
                keyboard.className = 'keyboard';
                keyboard.style.position = 'relative';
                keyboard.style.display = 'block';

                // Calculate cumulative positions from grid structure
                const keyPositions = new Map(); // keyCode -> {x, y} in absolute units
                const keyUnit = 50; // pixels per key unit

                if (state.config.grid && state.config.grid.length > 0) {
                    // Use grid to calculate cumulative positions
                    let cumulativeY = 0;
                    state.config.grid.forEach((row, rowIndex) => {
                        let cumulativeX = 0;
                        let rowHeight = 1; // Track the maximum height in this row

                        // First pass: calculate positions and track row height
                        const rowPositions = [];
                        row.forEach(keyCode => {
                            const layout = state.config.layoutData[keyCode];
                            if (layout) {
                                rowPositions.push({
                                    keyCode,
                                    x: cumulativeX + layout.x,
                                    y: cumulativeY + layout.y
                                });
                                rowHeight = 1; // Math.max(rowHeight, layout.h);
                                cumulativeX += layout.w + layout.x;
                            }
                        });

                        // Second pass: store all positions for this row
                        rowPositions.forEach(pos => {
                            keyPositions.set(pos.keyCode, {x: pos.x, y: pos.y});
                        });

                        // Move to next row (cumulative Y increases by row height)
                        cumulativeY += rowHeight;
                    });
                } else {
                    // Fallback: use layout.x as absolute position (backwards compatibility)
                    for (const keyCode in state.config.layoutData) {
                        const layout = state.config.layoutData[keyCode];
                        if (layout) {
                            keyPositions.set(keyCode, {x: layout.x, y: layout.y});
                        }
                    }
                }

                // Calculate keyboard dimensions from cumulative positions
                let maxX = 0, maxY = 0;
                for (const [keyCode, pos] of keyPositions) {
                    const layout = state.config.layoutData[keyCode];
                    if (layout) {
                        maxX = Math.max(maxX, pos.x + layout.w);
                        maxY = Math.max(maxY, pos.y + layout.h);
                    }
                }

                keyboard.style.width = `${maxX * keyUnit + 30}px`;
                keyboard.style.height = `${maxY * keyUnit + 30}px`;

                // Render each key with absolute positioning
                state.config.defsrc.forEach((keyCode, index) => {
                    const action = layerActions[index] || keyCode;
                    const layout = state.config.layoutData[keyCode];
                    const position = keyPositions.get(keyCode);

                    if (!layout || !position) return; // Skip if no layout data or position

                    const keyEl = document.createElement('div');
                    keyEl.className = 'key';
                    keyEl.style.position = 'absolute';
                    keyEl.style.left = `${position.x * keyUnit}px`;
                    keyEl.style.top = `${position.y * keyUnit}px`;
                    keyEl.style.width = `${layout.w * keyUnit - 4}px`;
                    keyEl.style.height = `${layout.h * keyUnit - 4}px`;

                    // Add styling based on action
                    if (action !== keyCode) {
                        if (action === '_' || action === 'XX') {
                            keyEl.classList.add('transparent');
                        } else if (action.startsWith('@')) {
                            const aliasValue = state.config.aliases[action.substring(1)];
                            if (aliasValue && aliasValue.includes('layer')) {
                                keyEl.classList.add('layer-switch');
                            } else {
                                keyEl.classList.add('modified');
                            }
                        } else if (typeof action === 'string' && action.includes('layer')) {
                            keyEl.classList.add('layer-switch');
                        } else if (typeof action === 'string' && action.includes('tap-hold')) {
                            keyEl.classList.add('tap-hold');
                        } else {
                            keyEl.classList.add('modified');
                        }
                    }

                    // Add layout editing features for base layer only
                    const isBaseLayer = layerName === 'base';
                    const inEditMode = state.ui.layoutEditMode && isBaseLayer;

                    // Set innerHTML first
                    keyEl.innerHTML = `
                        ${inEditMode ? `
                            <div class="key-controls">
                                <button class="key-control-btn" onclick="event.stopPropagation(); editKeyLayout('${keyCode}')"></button>
                                <button class="key-control-btn delete" onclick="event.stopPropagation(); deleteKey('${keyCode}')"></button>
                            </div>
                        ` : ''}
                        <div class="key-label">${keyCode}</div>
                        <div class="key-action">${formatAction(action)}</div>
                    `;

                    if (inEditMode) {
                        keyEl.classList.add('layout-edit-mode');
                        keyEl.draggable = true;

                        // Add drag handlers AFTER setting innerHTML
                        keyEl.addEventListener('dragstart', (e) => handleDragStart(e, keyCode));
                        keyEl.addEventListener('dragend', (e) => handleDragEnd(e, keyCode));
                        keyEl.addEventListener('dragover', (e) => handleDragOver(e, keyCode));
                        keyEl.addEventListener('drop', (e) => handleDrop(e, keyCode));

                        keyEl.onclick = (e) => {
                            if (!e.target.classList.contains('key-control-btn')) {
                                e.stopPropagation();
                            }
                        };
                    } else {
                        keyEl.onclick = () => openKeyModal(index, keyCode, layerName);
                    }

                    keyboard.appendChild(keyEl);
                });

                // Add "Add Key" button in edit mode for base layer only
                if (state.ui.layoutEditMode && layerName === 'base') {
                    const addBtn = document.createElement('button');
                    addBtn.className = 'add-key-btn';
                    addBtn.textContent = '+';
                    addBtn.onclick = addNewKey;
                    keyboard.appendChild(addBtn);
                }

                layerSection.appendChild(keyboard);
                container.appendChild(layerSection);
            }
        }

        function formatAction(action) {
            if (!action) return '';
            if (action === '_' || action === 'XX') return '';
            if (typeof action === 'string') {
                if (action.startsWith('(') && action.endsWith(')')) {
                    const match = action.match(/\((\w+)/);
                    return match ? match[1] : action;
                }
                return action;
            }
            return action.toString().substring(0, 8);
        }

        // ==================== LAYER MANAGEMENT ====================
        function renderLayers() {
            // No longer needed - layers are rendered directly in renderKeyboard
        }

        function switchLayer(layerName) {
            // No longer needed - all layers are visible at once
        }

        function deleteLayer(layerName) {
            if (Object.keys(state.config.layers).length <= 1) {
                alert('Cannot delete the last layer');
                return;
            }

            if (!confirm(`Delete layer "${layerName}"?`)) {
                return;
            }

            delete state.config.layers[layerName];
            renderKeyboard();
        }

        function openLayerModal() {
            document.getElementById('layerModal').classList.add('active');
            document.getElementById('newLayerName').value = '';
        }

        function closeLayerModal() {
            document.getElementById('layerModal').classList.remove('active');
        }

        function saveNewLayer() {
            const name = document.getElementById('newLayerName').value.trim();

            if (!name) {
                alert('Please enter a layer name');
                return;
            }

            if (state.config.layers[name]) {
                alert('A layer with this name already exists');
                return;
            }

            // Create new layer with all transparent keys
            state.config.layers[name] = state.config.defsrc.map(() => '_');

            closeLayerModal();
            renderKeyboard();
        }

        // ==================== KEY EDITING ====================
        function openKeyModal(defsrcIndex, keyCode, layerName) {
            state.ui.editingKeyIndex = defsrcIndex;
            state.ui.activeLayer = layerName;  // Track which layer is being edited

            const modal = document.getElementById('keyModal');
            const action = state.config.layers[layerName][defsrcIndex];

            document.getElementById('keyLabel').value = state.config.defsrc[defsrcIndex];

            // Determine action type
            let actionType = 'basic';
            if (action === '_' || action === 'XX') {
                actionType = 'transparent';
            } else if (action && action.startsWith('@')) {
                actionType = 'alias';
            } else if (action && typeof action === 'string' && action.includes('layer-switch')) {
                actionType = 'layer-switch';
            } else if (action && typeof action === 'string' && action.includes('layer-while-held')) {
                actionType = 'layer-while-held';
            } else if (action && typeof action === 'string' && action.includes('tap-hold')) {
                actionType = 'tap-hold';
            }

            document.getElementById('actionType').value = actionType;
            updateActionFields();

            // Populate fields based on current action
            if (actionType === 'basic') {
                document.getElementById('basicKey').value = action || '';
            } else if (actionType === 'alias') {
                document.getElementById('aliasName').value = action ? action.substring(1) : '';
            } else if (actionType === 'layer-switch' || actionType === 'layer-while-held') {
                const match = action.match(/\(layer-(?:switch|while-held)\s+(\w+)\)/);
                if (match) {
                    document.getElementById('targetLayer').value = match[1];
                }
            } else if (actionType === 'tap-hold') {
                const match = action.match(/\(tap-hold\s+(\S+)\s+(\S+)\s+(\d+)\)/);
                if (match) {
                    document.getElementById('tapAction').value = match[1];
                    document.getElementById('holdAction').value = match[2];
                    document.getElementById('tapHoldTimeout').value = match[3];
                }
            }

            modal.classList.add('active');
        }

        function closeKeyModal() {
            document.getElementById('keyModal').classList.remove('active');
        }

        function updateActionFields() {
            const actionType = document.getElementById('actionType').value;
            const fieldsContainer = document.getElementById('actionFields');

            let html = '';

            if (actionType === 'basic') {
                html = `
                    <div class="form-group">
                        <label>Key Code</label>
                        <input type="text" id="basicKey" placeholder="e.g., a, ret, spc">
                    </div>
                `;
            } else if (actionType === 'layer-switch' || actionType === 'layer-while-held') {
                const layers = Object.keys(state.config.layers);
                html = `
                    <div class="form-group">
                        <label>Target Layer</label>
                        <select id="targetLayer">
                            ${layers.map(l => `<option value="${l}">${l}</option>`).join('')}
                        </select>
                    </div>
                `;
            } else if (actionType === 'tap-hold') {
                html = `
                    <div class="form-group">
                        <label>Tap Action</label>
                        <input type="text" id="tapAction" placeholder="e.g., a">
                    </div>
                    <div class="form-group">
                        <label>Hold Action</label>
                        <input type="text" id="holdAction" placeholder="e.g., lctl">
                    </div>
                    <div class="form-group">
                        <label>Timeout (ms)</label>
                        <input type="number" id="tapHoldTimeout" value="200">
                    </div>
                `;
            } else if (actionType === 'alias') {
                html = `
                    <div class="form-group">
                        <label>Alias Name (without @)</label>
                        <input type="text" id="aliasName" placeholder="e.g., lyr">
                    </div>
                `;
            }

            fieldsContainer.innerHTML = html;
        }

        function saveKeyMapping() {
            const actionType = document.getElementById('actionType').value;
            let action = '';

            if (actionType === 'transparent') {
                action = '_';
            } else if (actionType === 'basic') {
                action = document.getElementById('basicKey').value.trim();
            } else if (actionType === 'layer-switch') {
                const layer = document.getElementById('targetLayer').value;
                action = `(layer-switch ${layer})`;
            } else if (actionType === 'layer-while-held') {
                const layer = document.getElementById('targetLayer').value;
                action = `(layer-while-held ${layer})`;
            } else if (actionType === 'tap-hold') {
                const tap = document.getElementById('tapAction').value.trim();
                const hold = document.getElementById('holdAction').value.trim();
                const timeout = document.getElementById('tapHoldTimeout').value;
                action = `(tap-hold ${tap} ${hold} ${timeout})`;
            } else if (actionType === 'alias') {
                const name = document.getElementById('aliasName').value.trim();
                action = `@${name}`;
            }

            if (!action) {
                alert('Please provide a valid action');
                return;
            }

            state.config.layers[state.ui.activeLayer][state.ui.editingKeyIndex] = action;

            closeKeyModal();
            renderKeyboard();
        }

        // ==================== FILE OPERATIONS ====================
        function loadFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const config = parseConfig(e.target.result);

                    if (!config.defsrc || config.defsrc.length === 0) {
                        alert('Invalid config: no defsrc found');
                        return;
                    }

                    if (Object.keys(config.layers).length === 0) {
                        alert('Invalid config: no layers found');
                        return;
                    }

                    state.config = config;
                    renderKeyboard();
                } catch (error) {
                    alert('Error parsing config: ' + error.message);
                    console.error(error);
                }
            };
            reader.readAsText(file);
        }

        function downloadConfig() {
            if (!state.config.defsrc || state.config.defsrc.length === 0) {
                alert('No configuration to download');
                return;
            }

            const configText = generateConfig(state.config);
            const blob = new Blob([configText], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = 'kanata-config.kbd';
            a.click();

            URL.revokeObjectURL(url);
        }

        function createSampleConfig() {
            // Create a simple sample configuration with ANSI 60% layout
            const defsrc = ['grv', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', 'min', 'eql', 'bspc',
                           'tab', 'q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p', 'lbrc', 'rbrc', 'bsls',
                           'caps', 'a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'scln', 'apo', 'ret',
                           'lsft', 'z', 'x', 'c', 'v', 'b', 'n', 'm', 'comm', 'dot', 'slsh', 'rsft',
                           'lctl', 'lmet', 'lalt', 'spc', 'ralt', 'rmet', 'rctl'];

            const sampleConfig = {
                defsrc: defsrc,
                layoutData: autoGenerateLayoutData(defsrc),
                layers: {
                    base: ['grv', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', 'min', 'eql', 'bspc',
                          'tab', 'q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p', 'lbrc', 'rbrc', 'bsls',
                          '@cap', 'a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'scln', 'apo', 'ret',
                          'lsft', 'z', 'x', 'c', 'v', 'b', 'n', 'm', 'comm', 'dot', 'slsh', 'rsft',
                          'lctl', 'lmet', 'lalt', 'spc', 'ralt', '@num', 'rctl'],
                    numbers: ['_', '_', '_', '_', '_', '_', '_', '7', '8', '9', '_', '_', '_', '_',
                             '_', '_', '_', '_', '_', '_', '_', '4', '5', '6', '_', '_', '_', '_',
                             '_', '_', '_', '_', '_', '_', '_', '1', '2', '3', '_', '_', '_',
                             '_', '_', '_', '_', '_', '_', '_', '_', '0', '_', '_', '_',
                             '_', '_', '_', '_', '_', '_', '_']
                },
                aliases: {
                    cap: '(tap-hold esc lctl 200)',
                    num: '(layer-while-held numbers)'
                }
            };

            state.config = sampleConfig;
            renderKeyboard();
        }

        // ==================== LAYOUT MANAGEMENT ====================
        const LAYOUT_PRESETS = {
            'ansi-60': `grv  1    2    3    4    5    6    7    8    9    0    -    =    bspc
tab  q    w    e    r    t    y    u    i    o    p    [    ]    \\
caps a    s    d    f    g    h    j    k    l    ;    '    ret
lsft z    x    c    v    b    n    m    ,    .    /    rsft
lctl lmet lalt           spc            ralt rmet menu rctl`,

            'ansi-tkl': `esc  f1   f2   f3   f4   f5   f6   f7   f8   f9   f10  f11  f12       prnt slck paus
grv  1    2    3    4    5    6    7    8    9    0    -    =    bspc  ins  home pgup
tab  q    w    e    r    t    y    u    i    o    p    [    ]    \\     del  end  pgdn
caps a    s    d    f    g    h    j    k    l    ;    '    ret
lsft z    x    c    v    b    n    m    ,    .    /    rsft            up
lctl lmet lalt           spc            ralt rmet menu rctl       left down rght`,

            'ansi-full': `esc  f1   f2   f3   f4   f5   f6   f7   f8   f9   f10  f11  f12       prnt slck paus    nlck kp/  kp*  kp-
grv  1    2    3    4    5    6    7    8    9    0    -    =    bspc  ins  home pgup    kp7  kp8  kp9  kp+
tab  q    w    e    r    t    y    u    i    o    p    [    ]    \\     del  end  pgdn    kp4  kp5  kp6
caps a    s    d    f    g    h    j    k    l    ;    '    ret                          kp1  kp2  kp3  kprt
lsft z    x    c    v    b    n    m    ,    .    /    rsft            up               kp0  kp.
lctl lmet lalt           spc            ralt rmet menu rctl       left down rght`,

            'kinesis-freestyle': `esc  f1   f2   f3   f4   f5   f6   f7   f8   f9   f10  f11  f12
=    1    2    3    4    5
tab  q    w    e    r    t
caps a    s    d    f    g
lsft z    x    c    v    b
grv  ins  left rght
lctl lalt
home end
bspc del  lmet
6    7    8    9    0    -
y    u    i    o    p    \\
h    j    k    l    ;    '
n    m    ,    .    /    rsft
up   down [    ]
ralt rctl
pgup pgdn
rmet spc  ret`
        };

        function onLayoutSelectorChange() {
            const preset = document.getElementById('layoutSelector').value;
            if (!preset) {
                return;  // User selected the placeholder option
            }
            applySelectedLayout(preset);
        }

        function applySelectedLayout(preset) {
            if (!preset) {
                alert('Please select a keyboard layout');
                return;
            }

            // Check if we have a precise layout definition
            if (PRECISE_LAYOUTS[preset]) {
                const layout = PRECISE_LAYOUTS[preset];

                // Save old defsrc for preserving layer mappings
                const oldDefsrc = state.config.defsrc || [];

                // Generate defsrc from grid (if available) or use legacy defsrc
                const newDefsrc = layout.grid
                    ? gridToDefsrc(layout.grid)
                    : layout.defsrc.slice();

                // Validation: check against old defsrc if present (for debugging)
                if (layout.defsrc && layout.grid) {
                    if (newDefsrc.length !== layout.defsrc.length) {
                        console.error('Grid-to-defsrc mismatch!', {
                            grid: newDefsrc.length,
                            defsrc: layout.defsrc.length
                        });
                    }
                }

                // Apply the precise layout
                state.config.defsrc = newDefsrc;
                state.config.grid = layout.grid ? JSON.parse(JSON.stringify(layout.grid)) : [];
                state.config.layoutData = JSON.parse(JSON.stringify(layout.layoutData));

                // Update all layers to match new defsrc length
                for (const [layerName, layerActions] of Object.entries(state.config.layers)) {
                    const newActions = [];
                    // For each key in new defsrc, try to preserve the action from the old config
                    newDefsrc.forEach((keyCode) => {
                        const oldIndex = oldDefsrc.indexOf(keyCode);
                        if (oldIndex >= 0 && layerActions[oldIndex]) {
                            newActions.push(layerActions[oldIndex]);
                        } else {
                            // New key or not found in old layout - use passthrough
                            newActions.push(keyCode);
                        }
                    });
                    state.config.layers[layerName] = newActions;
                }

                // Ensure we have at least a base layer
                if (Object.keys(state.config.layers).length === 0) {
                    state.config.layers.base = newDefsrc.slice();
                    state.ui.activeLayer = 'base';
                }

                renderKeyboard();
                return;
            }

            // Fallback to old parsing method for layouts without precise definitions
            const layoutText = LAYOUT_PRESETS[preset];
            if (!layoutText) {
                alert('Invalid layout selected');
                return;
            }

            // Parse the preset layout
            parseAndApplyLayout(layoutText);
            renderKeyboard();
        }

        function parseAndApplyLayout(layoutText) {
            // Parse the multi-line input - each line is a row
            const lines = layoutText.split('\n');
            const newDefsrc = [];
            const newLayoutData = {};

            let y = 0;
            for (const line of lines) {
                // Remove comments and extract just the keys
                const keysOnly = line.replace(/;;.*$/, '').trim();
                const keys = keysOnly.split(/\s+/).filter(k => k.length > 0);

                if (keys.length > 0) {
                    let x = 0;
                    for (const key of keys) {
                        newDefsrc.push(key);
                        const dims = getKeyDimensions(key);
                        newLayoutData[key] = {
                            x: x,
                            y: y,
                            w: dims.w,
                            h: dims.h
                        };
                        x += dims.w;
                    }
                    y += 1;
                }
            }

            if (newDefsrc.length === 0) {
                alert('Invalid layout - no keys found');
                return;
            }

            // Update defsrc
            const oldDefsrc = state.config.defsrc || [];
            state.config.defsrc = newDefsrc;
            state.config.layoutData = newLayoutData;

            // Update all layers to match new defsrc length
            for (const [layerName, layerActions] of Object.entries(state.config.layers)) {
                const newActions = [];

                // For each key in new defsrc, try to preserve the action from the old config
                newDefsrc.forEach((keyCode) => {
                    const oldIndex = oldDefsrc.indexOf(keyCode);
                    if (oldIndex >= 0 && layerActions[oldIndex]) {
                        newActions.push(layerActions[oldIndex]);
                    } else {
                        // New key or not found in old layout - use passthrough
                        newActions.push(keyCode);
                    }
                });

                state.config.layers[layerName] = newActions;
            }
        }

        // ==================== ALIAS MANAGEMENT ====================
        function openAliasesModal() {
            renderAliasesList();
            document.getElementById('aliasesModal').classList.add('active');
        }

        function closeAliasesModal() {
            document.getElementById('aliasesModal').classList.remove('active');
        }

        function renderAliasesList() {
            const container = document.getElementById('aliasesList');
            const aliases = state.config.aliases;

            if (Object.keys(aliases).length === 0) {
                container.innerHTML = '<div class="empty-aliases">No aliases defined. Click "Add New Alias" to create one.</div>';
                return;
            }

            container.innerHTML = '';
            for (const [name, value] of Object.entries(aliases)) {
                const item = document.createElement('div');
                item.className = 'alias-item';
                item.innerHTML = `
                    <div class="alias-item-content">
                        <div class="alias-name">@${name}</div>
                        <div class="alias-value">${value}</div>
                    </div>
                    <div class="alias-actions">
                        <button class="btn btn-sm" onclick="openEditAliasModal('${name}')">Edit</button>
                        <button class="btn btn-sm btn-danger" onclick="deleteAlias('${name}')">Delete</button>
                    </div>
                `;
                container.appendChild(item);
            }
        }

        function openEditAliasModal(aliasName) {
            state.ui.editingAlias = aliasName;

            if (aliasName) {
                document.getElementById('editAliasHeader').textContent = 'Edit Alias';
                document.getElementById('aliasNameInput').value = aliasName;
                document.getElementById('aliasNameInput').disabled = true;

                const value = state.config.aliases[aliasName];

                // Parse the value to determine action type
                if (value.includes('layer-switch')) {
                    document.getElementById('aliasActionType').value = 'layer-switch';
                } else if (value.includes('layer-while-held')) {
                    document.getElementById('aliasActionType').value = 'layer-while-held';
                } else if (value.includes('tap-hold')) {
                    document.getElementById('aliasActionType').value = 'tap-hold';
                } else {
                    document.getElementById('aliasActionType').value = 'custom';
                }

                updateAliasActionFields();

                // Populate fields
                const actionType = document.getElementById('aliasActionType').value;
                if (actionType === 'layer-switch' || actionType === 'layer-while-held') {
                    const match = value.match(/\(layer-(?:switch|while-held)\s+(\w+)\)/);
                    if (match && document.getElementById('aliasTargetLayer')) {
                        document.getElementById('aliasTargetLayer').value = match[1];
                    }
                } else if (actionType === 'tap-hold') {
                    const match = value.match(/\(tap-hold\s+(\S+)\s+(\S+)\s+(\d+)\)/);
                    if (match) {
                        document.getElementById('aliasTapAction').value = match[1];
                        document.getElementById('aliasHoldAction').value = match[2];
                        document.getElementById('aliasTapHoldTimeout').value = match[3];
                    }
                } else {
                    document.getElementById('aliasCustomValue').value = value;
                }
            } else {
                document.getElementById('editAliasHeader').textContent = 'Add New Alias';
                document.getElementById('aliasNameInput').value = '';
                document.getElementById('aliasNameInput').disabled = false;
                document.getElementById('aliasActionType').value = 'layer-while-held';
                updateAliasActionFields();
            }

            document.getElementById('editAliasModal').classList.add('active');
        }

        function closeEditAliasModal() {
            document.getElementById('editAliasModal').classList.remove('active');
        }

        function updateAliasActionFields() {
            const actionType = document.getElementById('aliasActionType').value;
            const fieldsContainer = document.getElementById('aliasActionFields');

            let html = '';

            if (actionType === 'layer-switch' || actionType === 'layer-while-held') {
                const layers = Object.keys(state.config.layers);
                html = `
                    <div class="form-group">
                        <label>Target Layer</label>
                        <select id="aliasTargetLayer">
                            ${layers.map(l => `<option value="${l}">${l}</option>`).join('')}
                        </select>
                    </div>
                `;
            } else if (actionType === 'tap-hold') {
                html = `
                    <div class="form-group">
                        <label>Tap Action</label>
                        <input type="text" id="aliasTapAction" placeholder="e.g., esc">
                    </div>
                    <div class="form-group">
                        <label>Hold Action</label>
                        <input type="text" id="aliasHoldAction" placeholder="e.g., lctl">
                    </div>
                    <div class="form-group">
                        <label>Timeout (ms)</label>
                        <input type="number" id="aliasTapHoldTimeout" value="200">
                    </div>
                `;
            } else if (actionType === 'custom') {
                html = `
                    <div class="form-group">
                        <label>Custom Expression</label>
                        <input type="text" id="aliasCustomValue" placeholder="e.g., (layer-toggle symbols)">
                    </div>
                `;
            }

            fieldsContainer.innerHTML = html;
        }

        function saveAlias() {
            const name = document.getElementById('aliasNameInput').value.trim();

            if (!name) {
                alert('Please enter an alias name');
                return;
            }

            if (!state.ui.editingAlias && state.config.aliases[name]) {
                alert('An alias with this name already exists');
                return;
            }

            const actionType = document.getElementById('aliasActionType').value;
            let value = '';

            if (actionType === 'layer-switch') {
                const layer = document.getElementById('aliasTargetLayer').value;
                value = `(layer-switch ${layer})`;
            } else if (actionType === 'layer-while-held') {
                const layer = document.getElementById('aliasTargetLayer').value;
                value = `(layer-while-held ${layer})`;
            } else if (actionType === 'tap-hold') {
                const tap = document.getElementById('aliasTapAction').value.trim();
                const hold = document.getElementById('aliasHoldAction').value.trim();
                const timeout = document.getElementById('aliasTapHoldTimeout').value;

                if (!tap || !hold) {
                    alert('Please provide both tap and hold actions');
                    return;
                }

                value = `(tap-hold ${tap} ${hold} ${timeout})`;
            } else if (actionType === 'custom') {
                value = document.getElementById('aliasCustomValue').value.trim();
                if (!value) {
                    alert('Please provide a custom expression');
                    return;
                }
            }

            state.config.aliases[name] = value;

            closeEditAliasModal();
            renderAliasesList();
            renderKeyboard();
        }

        function deleteAlias(name) {
            if (!confirm(`Delete alias "@${name}"?`)) {
                return;
            }

            // Check if alias is in use
            const aliasRef = `@${name}`;
            let inUse = false;

            for (const [layerName, actions] of Object.entries(state.config.layers)) {
                if (actions.includes(aliasRef)) {
                    inUse = true;
                    break;
                }
            }

            if (inUse) {
                if (!confirm(`Warning: Alias "@${name}" is currently used in one or more layers. Delete anyway?`)) {
                    return;
                }
            }

            delete state.config.aliases[name];
            renderAliasesList();
            renderKeyboard();
        }

        // ==================== LAYOUT EDITOR ====================
        let draggedKey = null;
        const keyUnit = 50; // Must match the keyUnit in renderKeyboard

        function toggleLayoutEditMode() {
            state.ui.layoutEditMode = !state.ui.layoutEditMode;
            const banner = document.getElementById('layoutEditBanner');
            const btn = document.getElementById('layoutEditBtn');

            if (state.ui.layoutEditMode) {
                banner.classList.add('active');
                btn.textContent = 'Exit Layout Edit Mode';
                btn.classList.add('btn-danger');
            } else {
                banner.classList.remove('active');
                btn.textContent = 'Edit Keyboard Layout';
                btn.classList.remove('btn-danger');
            }

            renderKeyboard();
        }

        function handleDragStart(e, keyCode) {
            state.ui.draggedKey = keyCode;
            state.ui.draggedIndex = state.config.defsrc.indexOf(keyCode);
            e.target.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', keyCode);
        }

        function handleDragEnd(e, keyCode) {
            e.target.classList.remove('dragging');

            // Remove insert indicator
            const indicator = document.getElementById('insert-indicator');
            if (indicator) indicator.remove();

            state.ui.draggedKey = null;
            state.ui.draggedIndex = -1;
            state.ui.currentDropTarget = null;
            state.ui.insertBefore = true;
        }

        function handleDragOver(e, keyCode) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';

            if (!state.ui.draggedKey || state.ui.draggedKey === keyCode) return;

            // Calculate which side of the key we're on
            const rect = e.currentTarget.getBoundingClientRect();
            const mouseX = e.clientX;
            const keyMiddle = rect.left + rect.width / 2;
            const insertBefore = mouseX < keyMiddle;

            // Update drop target info
            state.ui.currentDropTarget = keyCode;
            state.ui.insertBefore = insertBefore;

            // Update insert indicator position
            updateInsertIndicator(e.currentTarget, insertBefore);
        }

        function updateInsertIndicator(keyElement, insertBefore) {
            let indicator = document.getElementById('insert-indicator');
            if (!indicator) {
                indicator = document.createElement('div');
                indicator.id = 'insert-indicator';
                indicator.className = 'insert-indicator';
                keyElement.parentElement.appendChild(indicator);
            }

            const rect = keyElement.getBoundingClientRect();
            const parent = keyElement.parentElement.getBoundingClientRect();

            const x = insertBefore ? rect.left - parent.left - 2 : rect.right - parent.left - 2;
            const y = rect.top - parent.top;
            const height = rect.height;

            indicator.style.left = `${x}px`;
            indicator.style.top = `${y}px`;
            indicator.style.height = `${height}px`;
        }

        function handleDrop(e, targetKeyCode) {
            e.preventDefault();
            e.stopPropagation();

            if (!state.ui.draggedKey || state.ui.draggedKey === targetKeyCode) return;

            const draggedKeyCode = state.ui.draggedKey;
            const draggedLayout = state.config.layoutData[draggedKeyCode];
            const targetLayout = state.config.layoutData[targetKeyCode];
            const insertBefore = state.ui.insertBefore !== false; // default to true

            // Store the dragged key's original position
            const originalX = draggedLayout.x;
            const originalY = draggedLayout.y;

            // Calculate insert position
            let insertX, insertY;
            if (insertBefore) {
                // Insert before target
                insertX = targetLayout.x;
                insertY = targetLayout.y;
            } else {
                // Insert after target (to the right)
                insertX = targetLayout.x + targetLayout.w;
                insertY = targetLayout.y;
            }

            // Move dragged key to target position
            draggedLayout.x = insertX;
            draggedLayout.y = insertY;

            // Shift all keys that need to move
            const allKeys = Object.keys(state.config.layoutData);
            const sameRow = Math.abs(originalY - insertY) < 0.1;

            for (const keyCode of allKeys) {
                if (keyCode === draggedKeyCode) continue;

                const layout = state.config.layoutData[keyCode];

                if (sameRow) {
                    // Moving within same row
                    if (Math.abs(layout.y - originalY) < 0.1) {
                        if (originalX < insertX) {
                            // Moving right: keys between original and target shift left
                            if (layout.x > originalX && layout.x < insertX) {
                                layout.x -= draggedLayout.w;
                            }
                        } else {
                            // Moving left: keys between target and original shift right
                            if (layout.x >= insertX && layout.x < originalX) {
                                layout.x += draggedLayout.w;
                            }
                        }
                    }
                } else {
                    // Moving to different row
                    // On original row: shift keys after original position left
                    if (Math.abs(layout.y - originalY) < 0.1 && layout.x > originalX) {
                        layout.x -= draggedLayout.w;
                    }
                    // On target row: shift keys at/after insert position right
                    else if (Math.abs(layout.y - insertY) < 0.1 && layout.x >= insertX) {
                        layout.x += draggedLayout.w;
                    }
                }
            }

            // REBUILD defsrc and all layers based on visual position (top-to-bottom, left-to-right)
            rebuildDefsrcFromLayout();

            state.ui.draggedKey = null;
            state.ui.draggedIndex = -1;
            state.ui.currentDropTarget = null;

            renderKeyboard();
        }

        function rebuildDefsrcFromLayout() {
            // Get all keys with their positions
            const keysWithPositions = Object.keys(state.config.layoutData).map(keyCode => ({
                keyCode,
                x: state.config.layoutData[keyCode].x,
                y: state.config.layoutData[keyCode].y
            }));

            // Sort by position: top-to-bottom (y), then left-to-right (x)
            keysWithPositions.sort((a, b) => {
                if (Math.abs(a.y - b.y) < 0.1) {
                    // Same row, sort by x
                    return a.x - b.x;
                }
                // Different rows, sort by y
                return a.y - b.y;
            });

            // Create old defsrc index map
            const oldIndexMap = {};
            state.config.defsrc.forEach((keyCode, index) => {
                oldIndexMap[keyCode] = index;
            });

            // Build new defsrc
            const newDefsrc = keysWithPositions.map(k => k.keyCode);

            // Rebuild all layer arrays based on new order
            const newLayers = {};
            for (const layerName in state.config.layers) {
                newLayers[layerName] = newDefsrc.map(keyCode => {
                    const oldIndex = oldIndexMap[keyCode];
                    return state.config.layers[layerName][oldIndex];
                });
            }

            // Update state
            state.config.defsrc = newDefsrc;
            state.config.layers = newLayers;
        }

        function editKeyLayout(keyCode) {
            const layout = state.config.layoutData[keyCode];
            const newX = prompt(`Enter X position for ${keyCode} (current: ${layout.x}):`, layout.x);
            if (newX === null) return;

            const newY = prompt(`Enter Y position for ${keyCode} (current: ${layout.y}):`, layout.y);
            if (newY === null) return;

            const newW = prompt(`Enter width for ${keyCode} (current: ${layout.w}):`, layout.w);
            if (newW === null) return;

            const newH = prompt(`Enter height for ${keyCode} (current: ${layout.h}):`, layout.h || 1);
            if (newH === null) return;

            // Validate inputs
            const x = parseFloat(newX);
            const y = parseFloat(newY);
            const w = parseFloat(newW);
            const h = parseFloat(newH);

            if (isNaN(x) || isNaN(y) || isNaN(w) || isNaN(h)) {
                alert('Invalid input. Please enter valid numbers.');
                return;
            }

            if (w <= 0 || h <= 0) {
                alert('Width and height must be greater than 0.');
                return;
            }

            state.config.layoutData[keyCode] = { x, y, w, h };
            renderKeyboard();
        }

        function deleteKey(keyCode) {
            if (!confirm(`Delete key "${keyCode}" from the layout?\n\nThis will remove it from all layers.`)) {
                return;
            }

            // Find index of key in defsrc
            const index = state.config.defsrc.indexOf(keyCode);
            if (index === -1) return;

            // Remove from defsrc
            state.config.defsrc.splice(index, 1);

            // Remove from layoutData
            delete state.config.layoutData[keyCode];

            // Remove from all layers
            for (const layerName in state.config.layers) {
                state.config.layers[layerName].splice(index, 1);
            }

            renderKeyboard();
        }

        function addNewKey() {
            const keyCode = prompt('Enter key code (e.g., "a", "esc", "spc"):');
            if (!keyCode) return;

            // Check if key already exists
            if (state.config.defsrc.includes(keyCode)) {
                alert(`Key "${keyCode}" already exists in the layout.`);
                return;
            }

            const x = prompt('Enter X position:', '0');
            if (x === null) return;

            const y = prompt('Enter Y position:', '0');
            if (y === null) return;

            const w = prompt('Enter width:', '1');
            if (w === null) return;

            const h = prompt('Enter height:', '1');
            if (h === null) return;

            // Validate inputs
            const xNum = parseFloat(x);
            const yNum = parseFloat(y);
            const wNum = parseFloat(w);
            const hNum = parseFloat(h);

            if (isNaN(xNum) || isNaN(yNum) || isNaN(wNum) || isNaN(hNum)) {
                alert('Invalid input. Please enter valid numbers.');
                return;
            }

            if (wNum <= 0 || hNum <= 0) {
                alert('Width and height must be greater than 0.');
                return;
            }

            // Add to defsrc
            state.config.defsrc.push(keyCode);

            // Add to layoutData
            state.config.layoutData[keyCode] = { x: xNum, y: yNum, w: wNum, h: hNum };

            // Add to all layers with default value (same as keyCode)
            for (const layerName in state.config.layers) {
                state.config.layers[layerName].push(keyCode);
            }

            renderKeyboard();
        }

        // Initialize with default ANSI full keyboard layout
        function initializeDefaultLayout() {
            // Load ANSI full layout by default
            const defaultLayout = PRECISE_LAYOUTS['ansi-full'];

            if (defaultLayout) {
                // Generate defsrc from grid
                const defsrc = defaultLayout.grid
                    ? gridToDefsrc(defaultLayout.grid)
                    : defaultLayout.defsrc.slice();

                // Set up the state with the default layout
                state.config.defsrc = defsrc;
                state.config.grid = JSON.parse(JSON.stringify(defaultLayout.grid));
                state.config.layoutData = JSON.parse(JSON.stringify(defaultLayout.layoutData));

                // Create a default base layer with passthrough (each key maps to itself)
                state.config.layers.base = defsrc.slice();
                state.ui.activeLayer = 'base';
            }

            renderKeyboard();
        }

        initializeDefaultLayout();
    </script>
</body>
</html>
